if [[ -s $HOME/.bash_colors ]]; then
  source "$HOME/.bash_colors"
fi

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case $(echo "$TERM"|sed 's/-bce$//') in
    xterm|xterm-color|xterm-256color|screen|screen-256color) color_prompt=yes;;
esac

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
	if [[ -n "$SSH_CLIENT" ]]; then
		usercolor=$txtylw
	else
		usercolor=$txtgrn
	fi
	cwdcolor=$txtblu
fi
unset color_prompt force_color_prompt

# pilfered from https://github.com/epeli/vimconfig/blob/master/others/bashrc,
# thanks!
function generate_git_bar {
  git_status="$(env LC_MESSAGES=C git status 2> /dev/null)"
  branch_pattern="On branch ([^${IFS}]*)"
  detached_branch_pattern="Not currently on any branch"
  remote_pattern="Your branch is (.*) of"
  diverge_pattern="Your branch and (.*) have diverged"
  detached_at_pattern="HEAD detached at ([^${IFS}]*)"

  if [[ ${git_status}} =~ "Changed but not updated" ]]; then
    flags="${txtred}?" # Old git???
  fi

  if [[ ${git_status}} =~ "Untracked files" ]]; then
    flags="${flags}${txtred}!"
  fi

  if [[ ${git_status}} =~ "Changes not staged for commit" ]]; then
    flags="${flags}${txtred}âš¡"
  fi

  if [[ ${git_status}} =~ "Changes to be committed" ]]; then
    flags="${flags}${txtred}âˆš"
  fi

  if [[ ${git_status}} =~ "Unmerged paths" ]]; then
    flags="${flags}${txtred}â‰ˆ"
  fi

  if [ "$(git stash list)" ]; then
    flags="${flags}${txtred}Ë·"
  fi

  if [[ ${git_status} =~ ${remote_pattern} ]]; then
    if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
      flags="${flags}${txtylw}â†‘"
    else
      flags="${flags}${txtylw}â†“"
    fi
  fi

  if [[ ${git_status} =~ ${diverge_pattern} ]]; then
    flags="${flags}${txtylw}â†•"
  fi

  if [[ ${git_status} =~ ${branch_pattern} ]]; then
    branch="${BLUE}${BASH_REMATCH[1]}"
  elif [[ ${git_status} =~ ${detached_branch_pattern} ]]; then
    branch="${txtred}NO BRANCH"
  elif [[ ${git_status} =~ ${detached_at_pattern} ]]; then
    branch="${txtred}${BASH_REMATCH[1]}"
  fi


  if [ "${flags}" ]; then
    flags="${txtrst}|${flags}"
  fi

  hash=$(git rev-parse HEAD|head -c 7)

  echo "${txtrst}(${branch}${txtrst}|${txtylw}${hash}${flags}${txtrst})"
}

# also pilfered from the same source as above
function stopped_jobs(){
  if [[ "$(jobs)" =~ "Stopped" ]]; then
    echo "${txtrst}${txtred}âŒš "
  fi
}

function prompt_func() {
    # store retval from last command
    RET=$?

    RET_VALUE='$(echo $RET)' #Ret value not colorized - you can modify it.
    RET_SMILEY='$(if [[ $RET -eq 0 ]]; then echo -ne "\[$txtgrn\];)"; else echo -ne "\[$txtred\]:("; fi; echo -ne "\[$txtrst\]";)'

    if [[ -n "$SSH_CLIENT" ]]; then
        userhost='ðŸ”’ \u@\h'
    else
        userhost='\u'
    fi

    git rev-parse --git-dir > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        gitstuff=" $(generate_git_bar)"
    else
        gitstuff=""
    fi

    PS1="${debian_chroot:+($debian_chroot)}${usercolor}${userhost}${txtrst}:${cwdcolor}\w${txtrst}${gitstuff}$(stopped_jobs)\n${RET_VALUE} ${RET_SMILEY} \$ "

    # on tmux store the pwd for powerline
    PS1="$PS1"'$([ -n "$TMUX" ] && tmux setenv TMUXPWD_$(tmux display -p "#D" | tr -d %) "$PWD")'

    # If this is an xterm set the title to user@host:dir
    case "$TERM" in
        xterm*|rxvt*)
            PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
            ;;
        *)
            ;;
    esac
}

PROMPT_COMMAND=prompt_func

